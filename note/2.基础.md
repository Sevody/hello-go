## 函数
程序正常退出的代码为 0 

## 类型
1. 基本类型
- int
- float
- bool
- string

2. 结构化/复合类型
- struct
- array
- slice
- map
- channel

3. 描述类型行为
- interface

## Go 程序执行流程

## 类型转换

## 常量
一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。
常量的值必须是能够在编译时就能确定。
*在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用。*

## 运算符
```go
type ByteSize float64
const (
  _ = itoa
  KB ByteSize = 1<<(10*itoa)
  MB
  GB
  TB
  PB
  EB
  ZB
  YBj
)
```

|优先级|运算符|
|------|------|
|7|^ !|
|6|* / % << >> & &^|
|5|+ - \|^|
|4|== != < <= >= >|
|3|<-|
|2|&&|
|1|\|\||j

## 字符串
字符串是 UTF-8 字符的一个序列(字节数组)。
Go 程序不需要对 UTF-8 字符集的文本进行编码和解码。  
一般的比较运算符(==/!=/</>)通过在内存中按字节比较来实现字符串的对比。  

## 控制结构
- if-else
- for
- switch
- select (for channel)

## 函数
编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务（那就是函数）来解决。而且，同一个任务（函数）可以被调用多次，有助于代码重用。  
函数不能在其它函数里面声明（不能嵌套），不过我们可以通过匿名函数来破除这个限制。  

Go 默认使用按值传递来传递参数。而在函数调用时，像切片（silce）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递。  

尽量使用命名返回值，会使代码更清晰、更简短，同时更加容易读懂。

## 数组与切片

### 数组
数组是具有相同唯一类型的一组已编号且长度固定的数据项序列。  

把一个大数组传递给函数会消耗很多内存，有两种方法可以避免：
- 传递数组的指针
- 使用数组的切片

### 切片
切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型。  

切片的初始化格式是： `var slice []type = arr[start:end]` 。
表示 slice 是由数组 arr 从 start 索引到 end-1 索引之间的元素构成的子集。  

切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量。  

*注意绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针*  

当相关数组还没有定义时，我们可以使用 `make()` 函数来创建一个切片 同时创建好相关数组: `var slice []type = make([]type, len)`。

#### new() 和 make() 的区别
- `new(T)` 返回一个指向类型为 T ，值为 0 的地址的指针。它适用于值类型如数组和结构体。
- `make(T)` 返回一个类型为 T 的初始值。 它只适用于 3 种内建的引用类型：slice、map、channel。

换言之，new 函数分配内存，make 函数初始化。

## Map
map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value。

map 这种数据结构在其他编程语言中也成为字典（Python）、hash 和 HashTable等。

**map 是引用类型**

key 可以是任意用 `==` 或者 `!=` 操作符比较的类型，比如 string、int、float。所以数组、切片和结构体不能作为 key，但是只能和接口类型可以。如果要用结构体作为 key 可以提供 `Key()` 和 `Hash()` 方法，这样可以通过结构体的域计算出唯一的数字或者字符串的 key。

**不要使用 new, 永远用 make 来构造 map**

