# 标准库

# 结构体
无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的**选择器符**来引用结构体的字段。

表达式 `new(Type)` 和 `&Type{}` 是等价的。

## 匿名字段
结构体可以包含一个或多个匿名（内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身就是一个结构体类型，即 **结构体可以包含内嵌结构体**。  

Go 通过组合（匿名字段）模拟类似继承的行为。

```go
type A struct {
  ax, ay int
}

type B struct {
  A
  bx, by float32
}

func main() {
  b := B{A{1, 2}, 3.0, 4.0}
  fmt.Println(b.ax, b.ay, b.bx, b.by) //=> 1 2 3 4
  fmt.Println(b.A.ax) //=> 1
}
```
## 命名冲突
在一个结构体中对于每一种数据类型只能有一个匿名字段。

当两个字段拥有相同的名字是：

1. 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式
2. 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须有程序员自己修正。

## 方法
类型和作用在它上面定义的方法必须在同一个包里定义，所以不能再int、float或者类似这些的类型上定义方法。
但是有一个间接的方式：可以先定义改类型的别名类型，然后在为别名类型定义方法。或者将它作为匿名类型嵌入在一个新的结构体中。  

**指针方法和值方法都可以在指针或非指针上被调用** *(auto magic)*
```go
type List []int

func (l List) Len() int        { return len(l) }
func (l *List) Append(val int) { *l = append(*l, val) }

func main() {
	// 值
	var lst List
	lst.Append(1)
	fmt.Printf("%v (len: %d)", lst, lst.Len()) // [1] (len: 1)

	// 指针
	plst := new(List)
	plst.Append(2)
	fmt.Printf("%v (len: %d)", plst, plst.Len()) // &[2] (len: 1)
}
```

当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型**继承**了这些方法：**将父类型放在子类型中来实现亚型**。

```go
type Point struct {
	x, y float64
}

func (p *Point) Abs() float64 {
	return math.Sqrt(p.x*p.x + p.y*p.y)
}

type NamedPoint struct {
	Point
	name string
}

func main() {
	n := &NamedPoint{Point{3, 4}, "Pythagoras"}
	fmt.Println(n.Abs()) // 打印5
}
```

## 在类型中嵌入功能
1. 内聚（或组合）：包含一个所需功能类型的具体字段。
2. 内嵌： 内嵌（匿名地）所需功能类型。

一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。

Go 不需要一个显式的类定义，如同 Java、C++、C# 等那样，相反地，“类”是通过提供一组作用于一个共同类型的方法集来隐式定义的。类型可以是结构体或者任何用户自定义类型。

# 接口与反射

## 接口
接口提供一种方式来**说明**对象的行为：如果谁能搞定这件事，它就可以用在这儿。

按照约定，只包含一个方法的接口名字由方法名加 [e]r 后缀组成。

Go 语言中的接口都很简短，通常他们会包含 0 个、最多 3 个方法。

从某个类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显式地为这些导出方法额外定一个接口而已。

一个接口可以包含一个或者多个其他的接口，这相当于直接将这些内嵌方法列举在外层接口中一样。

**接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。**

### 类型断言
一个接口类型的变量 varI 中可以包含任何类型的值，必须有一种方式来检测它的**动态**类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用**类型断言**来测试在某个时刻 varI 是否包含类型 T 的值：

```go
v := varI.(T)

switch varI.(type)

sv, ok := v.(varI)
```

## 方法集与接口
Go 语言规范定义了接口方法集的调用规则：

- 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集
- 类型 T 的可调用方法集包含接受者为 T 的所有方法
- 类型 T 的可调用方法集不包含接受者为 *T 的方法

## 空接口
空接口或者最小接口不包含任何方法，它对实现不做任何要求。

任何其他类型都实现了空接口，可以给一个空接口类型的变量赋任何类型的值。

**每个 `interface {}` 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用用来存储它包含的数据或者指向数据的指针。**

不能直接复制数据切片至空接口切片，因为它们在内存中的布局是不一样的，必须使用 for-range 语句来一个一个显式地复制。

## 面向对象总结

> 
	OO 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？

	封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层:

	1）包范围内的：通过标识符首字母小写，对象 只在它所在的包内可见

	2）可导出的：通过标识符首字母大写，对象 对所在包以外也可见

	类型只拥有自己所在包中定义的方法。

	继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现
	多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。
	类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。
	Go 接口不是 Java 和 C# 接口的变体，而且：接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。


