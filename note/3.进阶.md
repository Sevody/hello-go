## 标准库

## 结构体
无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的**选择器符**来引用结构体的字段。

表达式 `new(Type)` 和 `&Type{}` 是等价的。

### 匿名字段
结构体可以包含一个或多个匿名（内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身就是一个结构体类型，即 **结构体可以包含内嵌结构体**。  

Go 通过组合（匿名字段）模拟类似继承的行为。

```go
type A struct {
  ax, ay int
}

type B struct {
  A
  bx, by float32
}

func main() {
  b := B{A{1, 2}, 3.0, 4.0}
  fmt.Println(b.ax, b.ay, b.bx, b.by) //=> 1 2 3 4
  fmt.Println(b.A.ax) //=> 1
}
```
### 命名冲突
在一个结构体中对于每一种数据类型只能有一个匿名字段。

当两个字段拥有相同的名字是：

1. 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式
2. 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须有程序员自己修正。

### 方法
类型和作用在它上面定义的方法必须在同一个包里定义，所以不能再int、float或者类似这些的类型上定义方法。
但是有一个间接的方式：可以先定义改类型的别名类型，然后在为别名类型定义方法。或者将它作为匿名类型嵌入在一个新的结构体中。  

**指针方法和值方法都可以在指针或非指针上被调用** *(auto magic)*
```go
type List []int

func (l List) Len() int        { return len(l) }
func (l *List) Append(val int) { *l = append(*l, val) }

func main() {
	// 值
	var lst List
	lst.Append(1)
	fmt.Printf("%v (len: %d)", lst, lst.Len()) // [1] (len: 1)

	// 指针
	plst := new(List)
	plst.Append(2)
	fmt.Printf("%v (len: %d)", plst, plst.Len()) // &[2] (len: 1)
}
```

当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型**继承**了这些方法：**将父类型放在子类型中来实现亚型**。

```go
type Point struct {
	x, y float64
}

func (p *Point) Abs() float64 {
	return math.Sqrt(p.x*p.x + p.y*p.y)
}

type NamedPoint struct {
	Point
	name string
}

func main() {
	n := &NamedPoint{Point{3, 4}, "Pythagoras"}
	fmt.Println(n.Abs()) // 打印5
}
```

### 在类型中嵌入功能
1. 内聚（或组合）：包含一个所需功能类型的具体字段。
2. 内嵌： 内嵌（匿名地）所需功能类型。

一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。





